%define CODE_JUMP 0x600
%define STACK_JUMP 0x200
%define CS_OFFSET -0x1

mov cx , ((end_Copy - start_Copy)/ 2)
mov bp, ax
lea si, [bp + start_Copy]
rep movsw

mov bx , di
mov al , 0xA3
stosw

push ds 
push es
pop ds
pop es

mov word [di] , 0x1000 + CS_OFFSET

push cs
pop ss
mov sp, ax ;put sp in the right place

mov dx, 0xabcd ; timer
mov word [bx + (update_sp_si_flag - start_Copy)], STACK_JUMP
mov word [bx + (update_di_si_flag - start_Copy)],CODE_JUMP + (end_Copy-start_Copy - 1) ;
mov bp, CODE_JUMP

sub word [bx], CODE_JUMP
mov di, [bx]
add di, 0x10 * CS_OFFSET

sub sp, STACK_JUMP

mov si,start - start_Copy
dec dx
jz kill
movsw
dec di
call far [bx]

start_Copy:

dec dx
movsw
movsw
jz kill
movsw
movsw
movsw
movsw
sub di, [bx + si]
movsw
dec di
call far [bx]
nop
start:
update_di_si_flag:
call far [bx]
movsw


movsw
movsw
sub word [bx], bp
movsw
sub sp, [bx + si]
movsw
movsw
update_sp_si_flag:
xor si,si
movsw
movsw
end_Copy:
;need to make sure kill lands on a byte from cs of the call far bombing that kills for sure
kill: