%define CODE_JUMP 0x600
%define STACK_JUMP 0x200
%define CS_OFFSET -0x1
%define ZOMBIES_TIMER 0X0122
%define TO_JUMP 0XdfA2
%define ZOMBIE_DIST 0x1400
%define SP_SHARE_ADDR 0xDEFF

delete_this:
    mov [0], ax
    add word [0], zombie    

mov word [SP_SHARE_ADDR], TO_JUMP-STACK_JUMP-ZOMBIE_DIST


mov cx , ((end_Copy - start_Copy)/ 2)
mov si, ax


lea si, [si + start_Copy]
push ss
pop es
rep movsw

push ds 
push es
pop ds
pop es

mov bx , 0x50
mov ax , TO_JUMP
mov [bx],ax

sub word [bx], CODE_JUMP

push cs
pop ss
mov sp, ax ;put sp in the right place

xor dx, dx ; timer
mov di, [bx]
add di, 0x10 * CS_OFFSET

sub sp, STACK_JUMP

mov si,start - start_Copy
movsw
dec di

zombie_here:
mov word [bx + 2], 0x1000 + CS_OFFSET
mov word [bx + (update_sp_si_flag - start_Copy)], STACK_JUMP
mov word [bx + (update_di_si_flag - start_Copy)],CODE_JUMP + (end_Copy-start_Copy - 2) ;
mov bp, CODE_JUMP

call far [bx]

start_Copy:

dec dx
movsw
movsw
jz kill
movsw
movsw
movsw
movsw
movsw
sub di, [bx + si]
movsw
dec di
call_far:
call far [bx]

start:
update_di_si_flag:
call far [bx]

movsw
movsw
movsw
sub word [bx], bp
movsw
sub sp, [bx + si]
movsw
update_sp_si_flag:
movsw
xor si,si
movsw
nop
end_Copy:
;need to make sure kill lands on a byte from cs of the call far bombing that kills for sure
nop
kill:

other_sur:
    mov cx, TO_JUMP - STACK_JUMP + ZOMBIE_DIST
jmp skip_beggining
zombie:
; to not interupt the stack, cx will hold sp for now.
        mov cx, [SP_SHARE_ADDR]
        sub word [SP_SHARE_ADDR], ZOMBIE_DIST
	skip_beggining:
	push ss
	pop ds
	
        push cs
	pop es
	
	push cs
	pop ss
	
	mov bx,0x50
	mov word [bx], TO_JUMP ;need to add here the addres
	
	mov word [0], 0xcccc
	mov word [2], 0xffcc
	mov word [4], 0xcc1f
	mov word [6], 0xcccc
	
	mov dx, ZOMBIES_TIMER
        mov sp, cx
	mov di, sp
	mov si,start - start_Copy +2
	sub word [bx], CODE_JUMP
	
	jmp zombie_here