%define CODE_JUMP 0x600
%define STACK_JUMP 0x200
%define CS_OFFSET -0x1
%define RANDOM_LOCATION 0xDEAD

delete_this:
    mov [0], ax
    add word [0], zombie
    
mov byte [RANDOM_LOCATION], 0xA3
mov byte [RANDOM_LOCATION+1], ah
sub word [RANDOM_LOCATION], CODE_JUMP
mov word [RANDOM_LOCATION+2], 0x1000 + CS_OFFSET
;store on cs the long pointer

mov cx , ((end_Copy - start_Copy)/ 2)
mov bp, ax
lea si, [bp + start_Copy]
rep movsw

jmp after_zombie
zombie:
    push cs
    push cs
    push ss
    push ss
    pop es
    mov si, RANDOM_LOCATION
    xor di, di
    movsw
    movsw
    xor bx, bx
    
    mov si, 30
    pop ds
    pop es
    pop ss
    call far [bx]
after_zombie:
mov bx , di
mov al , 0xA3
stosw

push ds 
push es
pop ds
pop es

mov word [di] , 0x1000 + CS_OFFSET

push cs
pop ss
mov sp, ax ;put sp in the right place

mov dx, 0xabcd ; timer
mov word [bx + (update_sp_si_flag - start_Copy)], STACK_JUMP
mov word [bx + (update_di_si_flag - start_Copy)],CODE_JUMP + (end_Copy-start_Copy - 1) ;
mov bp, CODE_JUMP

sub word [bx], CODE_JUMP
mov di, [bx]
add di, 0x10 * CS_OFFSET

sub sp, STACK_JUMP

mov si,start - start_Copy
movsw
dec di
call far [bx]

start_Copy:

dec dx
movsw
movsw
jz kill
movsw
movsw
movsw
movsw
movsw
sub di, [bx + si]
movsw
dec di
call_far:
call far [bx]

start:
update_di_si_flag:
call far [bx]

movsw
movsw
sub word [bx], bp
movsw
sub sp, [bx + si]
movsw
update_sp_si_flag:
movsw
xor si,si
movsw
end_Copy:
;need to make sure kill lands on a byte from cs of the call far bombing that kills for sure
kill: