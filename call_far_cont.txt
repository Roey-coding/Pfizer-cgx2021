%define CODE_JUMP 0x600
%define STACK_JUMP 0x200
%define CS_OFFSET -0x1
%define ZOMBIES_TIMER 0X0122
%define TO_JUMP 0XdfA2
%define ZOMBIE_DIST 0x1400
%define SP_SHARE_ADDR 0xDEFF

   %define BYTE_AFTER_DESIGNATED_JUMP 0xF8E2
%define DESIGNATED_JUMP_POSITION 0x70
%define OPCODE_FOR_JMP 0xA5FF
%define CCCC 0XCCCC
%define MEMORY_XCHANGE_AREA 0xDDDD
%define FIRST64 0x3F00
%define SECOND64 0xDF00
%define THIRD64 0x5F00
%define FIRST32 0x3D00
%define SECOND32 0xDD00
%define THIRD32 0x5D00
%define FIRST16 0xD900 ;
%define SECOND16 0x3900
%define THIRD16 0x5900
%define FIRST8 0x3100 ;
%define SECOND8 0xD100
%define THIRD8 0x5100
%define FIRST4 0x2100

%define ZOMBPLUS 0x0200
%define ZOMBPLUS87 0x0300
%define CARPET 0xF0F1

%define FIRST_ITERATION 41
%define REAL_OPS_BEFORE_TREE 23
%define NOPS 10
%define OPCODES_AFTER_NRG 19
%define ITERATIONS_AFTER_NRG 13
%define JUMP_NRG_BYTE 0x67
%define DOUBLE_NOP 0x9090
%define DEADS 6
%define START_LIST 224


; Saving the at-risk code in stack.
mov si, ax
and si, 0xff00
add si, 0x0100
push word [si]
add si, 0x0100
push word [si]
; Finish save.

mov bx, [MEMORY_XCHANGE_AREA]

mov cx, bx
add cx, 0x0300
and cx, 0x0700
; Now cx is the zombie we'd like to find.


push bx
mov bx, cx
;;;;;;;;;;;;;;;;;;;;
mov dx, ax
add dx, zombie_here
mov byte [CCCC], 0xB8
mov word [CCCC + 1], dx
mov word [CCCC + 3], 0xE0FF
mov word [0x26FF], CCCC
;;;;end

; Dead stuffs
mov cx, DEADS
dead_iterations:
loop dead_iterations

mov cx, CARPET					; Would you take a look at this beauty?
mov [FIRST32 + bx], cx
mov [SECOND32 + bx], cx
mov [THIRD32 + bx], cx
mov [FIRST16 + bx], cx
mov [SECOND16 + bx], cx
mov [THIRD16 + bx], cx
mov [FIRST8 + bx], cx
mov [SECOND8 + bx], cx
mov [THIRD8 + bx], cx
mov [FIRST4 + bx], cx




xchg bx,cx
; Realese second survivor
pop bx
push ax
mov ax, CARPET
add bx, START_LIST
push bx
mov word [BYTE_AFTER_DESIGNATED_JUMP], CCCC
mov word [bx + (JUMP_NRG_BYTE - START_LIST)], 0x8433
xchg bx,cx


; This next line should be executed at step 41
xor ax, [FIRST32 + bx]
xor ax, [SECOND32 + bx]
xor ax, [THIRD32 + bx]
xor ax, [FIRST16 + bx]
xor ax, [SECOND16 + bx]
xor ax, [THIRD16 + bx]
xor ax, [FIRST8 + bx]
xor ax, [SECOND8 + bx]
xor ax, [THIRD8 + bx]
xor ax, [FIRST4 + bx]

xchg bx,cx

;This will be optimized for ZOMA only, for a different zombie see excel that does not yet exist.

; This'll be once we have finished all the xor's, 
; we'd like to have around 95% certainty that we'd hit a zombie written code by now.

xlatb                   ;al = startL^startH
xchg al, ah             ;ah = startL^startH, al = zombArr[startL]
xlatb                   ;al = startL
xor ah, al

; ax = zombie base address

mov bx, ax
mov word [bx+DESIGNATED_JUMP_POSITION], OPCODE_FOR_JMP

pop ax
pop cx
mov [si], cx
sub si, 0x0100
pop cx
mov [si], cx

push ds
pop es
mov di, 0
mov ax, ZOMBPLUS87 ;little indi
mov dx, 0xE3D1 ;little indi
mov bx, ZOMBPLUS87
mov cx, OPCODE_FOR_JMP 
int 0x87



mov word [SP_SHARE_ADDR], TO_JUMP-STACK_JUMP-ZOMBIE_DIST


mov cx , ((end_Copy - start_Copy)/ 2)
mov si, ax


lea si, [si + start_Copy]
push ss
pop es
rep movsw

push ds 
push es
pop ds
pop es

mov bx , 0x50
mov ax , TO_JUMP
mov [bx],ax

sub word [bx], CODE_JUMP

push cs
pop ss
mov sp, ax ;put sp in the right place

xor dx, dx ; timer
mov di, [bx]
add di, 0x10 * CS_OFFSET

sub sp, STACK_JUMP

mov si,start - start_Copy
movsw
dec di

zombie:
mov word [bx + 2], 0x1000 + CS_OFFSET
mov word [bx + (update_sp_si_flag - start_Copy)], STACK_JUMP
mov word [bx + (update_di_si_flag - start_Copy)],CODE_JUMP + (end_Copy-start_Copy - 2) ;
mov bp, CODE_JUMP

call far [bx]

start_Copy:

dec dx
movsw
movsw
jz kill
movsw
movsw
movsw
movsw
movsw
sub di, [bx + si]
movsw
dec di
call_far:
call far [bx]

start:
update_di_si_flag:
call far [bx]

movsw
movsw
movsw
sub word [bx], bp
movsw
sub sp, [bx + si]
movsw
update_sp_si_flag:
movsw
xor si,si
movsw
nop
end_Copy:
;need to make sure kill lands on a byte from cs of the call far bombing that kills for sure
nop
kill:

other_sur:
    mov cx, TO_JUMP - STACK_JUMP + ZOMBIE_DIST
jmp skip_beggining
zombie_here:
	zombie_here:

push ds
pop es
mov di, 0
mov ax, ZOMBPLUS87 ;little indi
mov dx, 0xE3D1 ;little indi
mov bx, ZOMBPLUS87
mov cx, OPCODE_FOR_JMP 
int 0x87



; to not interupt the stack, cx will hold sp for now.
        mov cx, [SP_SHARE_ADDR]
        sub word [SP_SHARE_ADDR], ZOMBIE_DIST
	skip_beggining:
	push ss
	pop ds
	
        push cs
	pop es
	
	push cs
	pop ss
	
	mov bx,0x50
	mov word [bx], TO_JUMP ;need to add here the addres
	
	mov word [0], 0xcccc
	mov word [2], 0xffcc
	mov word [4], 0xcc1f
	mov word [6], 0xcccc
	
	mov dx, ZOMBIES_TIMER
        mov sp, cx
	mov di, sp
	mov si,start - start_Copy +2
	sub word [bx], CODE_JUMP
	
	jmp zombie