%define CODE_JUMP 0x600
%define STACK_JUMP 0x200
%define CS_OFFSET -0x1

mov cx , ((end_Copy - start_Copy)/ 2)
mov bp, ax
lea si, [bp + start_Copy]
rep movsw

mov bx , di
mov al , 0xA3
stosw

push ds 
push es
pop ds
pop es

mov word [di] , 0x1000 + CS_OFFSET

push cs
pop ss
mov sp, ax ;put sp in the right place

mov dx, 0xabcd ; timer

sub word [bx], CODE_JUMP
mov di, [bx]
add di, 0x10 * CS_OFFSET
jmp start_first_time

start_Copy:
call far [bx]
rep movsw

start:
sub word [bx], CODE_JUMP
mov di, sp
sub di, CODE_JUMP + 0x10 * CS_OFFSET 
add di, 0x10 * CS_OFFSET
start_first_time:
sub sp, STACK_JUMP

;mov di, [bx]
mov cl, (end_Copy-start)/2
xor si,si
dec dx
jz kill
movsw
dec di
call far [bx]

end_Copy:
;need to make sure kill lands on a byte from cs of the call far bombing that kills for sure
kill: